{"ast":null,"code":"'use strict';\n\nvar _possibleConstructorReturn = require(\"/Users/zaiba/Desktop/WebDev/in-chat-nito/react-backend/client/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/Users/zaiba/Desktop/WebDev/in-chat-nito/react-backend/client/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/Users/zaiba/Desktop/WebDev/in-chat-nito/react-backend/client/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _assertThisInitialized = require(\"/Users/zaiba/Desktop/WebDev/in-chat-nito/react-backend/client/node_modules/@babel/runtime/helpers/assertThisInitialized\");\n\nvar _classCallCheck = require(\"/Users/zaiba/Desktop/WebDev/in-chat-nito/react-backend/client/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/zaiba/Desktop/WebDev/in-chat-nito/react-backend/client/node_modules/@babel/runtime/helpers/createClass\");\n\nvar http = require('http');\n\nvar EventEmitter = require('events');\n\nvar EE_ERROR = 'Registering more than one listener to a WebSocket is not supported.';\nvar DEFAULT_PAYLOAD_LIMIT = 16777216;\nvar _upgradeReq = null;\n\nfunction noop() {}\n\nfunction abortConnection(socket, code, name) {\n  socket.end('HTTP/1.1 ' + code + ' ' + name + '\\r\\n\\r\\n');\n}\n\nfunction emitConnection(ws) {\n  this.emit('connection', ws, _upgradeReq);\n}\n\nfunction onServerMessage(message, webSocket) {\n  webSocket.internalOnMessage(message);\n}\n\nvar native = function () {\n  try {\n    try {\n      return process.binding('uws_builtin');\n    } catch (e) {\n      return require(\"./uws_\".concat(process.platform, \"_\").concat(process.versions.modules));\n    }\n  } catch (e) {\n    var version = process.version.substring(1).split('.').map(function (n) {\n      return parseInt(n);\n    });\n    var lessThanSixFour = version[0] < 6 || version[0] === 6 && version[1] < 4;\n\n    if (process.platform === 'win32' && lessThanSixFour) {\n      throw new Error('µWebSockets requires Node.js 6.4.0 or greater on Windows.');\n    } else {\n      throw new Error('Compilation of µWebSockets has failed and there is no pre-compiled binary ' + 'available for your system. Please install a supported C++11 compiler and reinstall the module \\'uws\\'.');\n    }\n  }\n}();\n\nnative.setNoop(noop);\nvar clientGroup = native.client.group.create(0, DEFAULT_PAYLOAD_LIMIT);\nnative.client.group.onConnection(clientGroup, function (external) {\n  var webSocket = native.getUserData(external);\n  webSocket.external = external;\n  webSocket.internalOnOpen();\n});\nnative.client.group.onMessage(clientGroup, function (message, webSocket) {\n  webSocket.internalOnMessage(message);\n});\nnative.client.group.onDisconnection(clientGroup, function (external, code, message, webSocket) {\n  webSocket.external = null;\n  process.nextTick(function () {\n    webSocket.internalOnClose(code, message);\n  });\n  native.clearUserData(external);\n});\nnative.client.group.onPing(clientGroup, function (message, webSocket) {\n  webSocket.onping(message);\n});\nnative.client.group.onPong(clientGroup, function (message, webSocket) {\n  webSocket.onpong(message);\n});\nnative.client.group.onError(clientGroup, function (webSocket) {\n  process.nextTick(function () {\n    webSocket.internalOnError({\n      message: 'uWs client connection error',\n      stack: 'uWs client connection error'\n    });\n  });\n});\n\nvar WebSocket =\n/*#__PURE__*/\nfunction () {\n  function WebSocket(external) {\n    _classCallCheck(this, WebSocket);\n\n    this.external = external;\n    this.internalOnMessage = noop;\n    this.internalOnClose = noop;\n    this.onping = noop;\n    this.onpong = noop;\n  }\n\n  _createClass(WebSocket, [{\n    key: \"emit\",\n    value: function emit(eventName, arg1, arg2) {\n      if (eventName === 'message') {\n        this.internalOnMessage(arg1);\n      } else if (eventName === 'close') {\n        this.internalOnClose(arg1, arg2);\n      } else if (eventName === 'ping') {\n        this.onping(arg1);\n      } else if (eventName === 'pong') {\n        this.onpong(arg1);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"on\",\n    value: function on(eventName, f) {\n      if (eventName === 'message') {\n        if (this.internalOnMessage !== noop) {\n          throw Error(EE_ERROR);\n        }\n\n        this.internalOnMessage = f;\n      } else if (eventName === 'close') {\n        if (this.internalOnClose !== noop) {\n          throw Error(EE_ERROR);\n        }\n\n        this.internalOnClose = f;\n      } else if (eventName === 'ping') {\n        if (this.onping !== noop) {\n          throw Error(EE_ERROR);\n        }\n\n        this.onping = f;\n      } else if (eventName === 'pong') {\n        if (this.onpong !== noop) {\n          throw Error(EE_ERROR);\n        }\n\n        this.onpong = f;\n      } else if (eventName === 'open') {\n        if (this.internalOnOpen !== noop) {\n          throw Error(EE_ERROR);\n        }\n\n        this.internalOnOpen = f;\n      } else if (eventName === 'error' && this instanceof WebSocketClient) {\n        if (this.internalOnError !== noop) {\n          throw Error(EE_ERROR);\n        }\n\n        this.internalOnError = f;\n      }\n\n      return this;\n    }\n  }, {\n    key: \"once\",\n    value: function once(eventName, f) {\n      var _this = this;\n\n      if (eventName === 'message') {\n        if (this.internalOnMessage !== noop) {\n          throw Error(EE_ERROR);\n        }\n\n        this.internalOnMessage = function (message) {\n          _this.internalOnMessage = noop;\n          f(message);\n        };\n      } else if (eventName === 'open') {\n        if (this.internalOnOpen !== noop) {\n          throw Error(EE_ERROR);\n        }\n\n        this.internalOnOpen = function () {\n          _this.internalOnOpen = noop;\n          f();\n        };\n      } else if (eventName === 'close') {\n        if (this.internalOnClose !== noop) {\n          throw Error(EE_ERROR);\n        }\n\n        this.internalOnClose = function (code, message) {\n          _this.internalOnClose = noop;\n          f(code, message);\n        };\n      } else if (eventName === 'ping') {\n        if (this.onping !== noop) {\n          throw Error(EE_ERROR);\n        }\n\n        this.onping = function () {\n          _this.onping = noop;\n          f();\n        };\n      } else if (eventName === 'pong') {\n        if (this.onpong !== noop) {\n          throw Error(EE_ERROR);\n        }\n\n        this.onpong = function () {\n          _this.onpong = noop;\n          f();\n        };\n      }\n\n      return this;\n    }\n  }, {\n    key: \"removeAllListeners\",\n    value: function removeAllListeners(eventName) {\n      if (!eventName || eventName === 'message') {\n        this.internalOnMessage = noop;\n      }\n\n      if (!eventName || eventName === 'open') {\n        this.internalOnOpen = noop;\n      }\n\n      if (!eventName || eventName === 'close') {\n        this.internalOnClose = noop;\n      }\n\n      if (!eventName || eventName === 'ping') {\n        this.onping = noop;\n      }\n\n      if (!eventName || eventName === 'pong') {\n        this.onpong = noop;\n      }\n\n      return this;\n    }\n  }, {\n    key: \"removeListener\",\n    value: function removeListener(eventName, cb) {\n      if (eventName === 'message' && this.internalOnMessage === cb) {\n        this.internalOnMessage = noop;\n      } else if (eventName === 'open' && this.internalOnOpen === cb) {\n        this.internalOnOpen = noop;\n      } else if (eventName === 'close' && this.internalOnClose === cb) {\n        this.internalOnClose = noop;\n      } else if (eventName === 'ping' && this.onping === cb) {\n        this.onping = noop;\n      } else if (eventName === 'pong' && this.onpong === cb) {\n        this.onpong = noop;\n      }\n\n      return this;\n    }\n  }, {\n    key: \"ping\",\n    // from here down, functions are not common between client and server\n    value: function ping(message, options, dontFailWhenClosed) {\n      if (this.external) {\n        native.server.send(this.external, message, WebSocketClient.OPCODE_PING, false);\n      }\n    }\n  }, {\n    key: \"terminate\",\n    value: function terminate() {\n      if (this.external) {\n        native.server.terminate(this.external);\n        this.external = null;\n      }\n    }\n  }, {\n    key: \"send\",\n    value: function send(message, options, cb, compress) {\n      if (this.external) {\n        if (typeof options === 'function') {\n          cb = options;\n          options = null;\n        }\n\n        var binary = options && typeof options.binary === 'boolean' ? options.binary : typeof message !== 'string';\n        native.server.send(this.external, message, binary ? WebSocketClient.OPCODE_BINARY : WebSocketClient.OPCODE_TEXT, cb ? function () {\n          process.nextTick(cb);\n        } : undefined, compress);\n      } else if (cb) {\n        cb(new Error('not opened'));\n      }\n    }\n  }, {\n    key: \"close\",\n    value: function close(code, data) {\n      if (this.external) {\n        native.server.close(this.external, code, data);\n        this.external = null;\n      }\n    }\n  }, {\n    key: \"upgradeReq\",\n    get: function get() {\n      return _upgradeReq;\n    }\n  }, {\n    key: \"onmessage\",\n    set: function set(f) {\n      if (f) {\n        this.internalOnMessage = function (message) {\n          f({\n            data: message\n          });\n        };\n      } else {\n        this.internalOnMessage = noop;\n      }\n    }\n  }, {\n    key: \"onopen\",\n    set: function set(f) {\n      if (f) {\n        this.internalOnOpen = f;\n      } else {\n        this.internalOnOpen = noop;\n      }\n    }\n  }, {\n    key: \"onclose\",\n    set: function set(f) {\n      if (f) {\n        this.internalOnClose = function (code, message) {\n          f({\n            code: code,\n            reason: message\n          });\n        };\n      } else {\n        this.internalOnClose = noop;\n      }\n    }\n  }, {\n    key: \"onerror\",\n    set: function set(f) {\n      if (f && this instanceof WebSocketClient) {\n        this.internalOnError = f;\n      } else {\n        this.internalOnError = noop;\n      }\n    }\n  }, {\n    key: \"OPEN\",\n    get: function get() {\n      return WebSocketClient.OPEN;\n    }\n  }, {\n    key: \"CLOSED\",\n    get: function get() {\n      return WebSocketClient.CLOSED;\n    }\n  }, {\n    key: \"readyState\",\n    get: function get() {\n      return this.external ? WebSocketClient.OPEN : WebSocketClient.CLOSED;\n    }\n  }, {\n    key: \"_socket\",\n    get: function get() {\n      var address = this.external ? native.getAddress(this.external) : new Array(3);\n      return {\n        remotePort: address[0],\n        remoteAddress: address[1],\n        remoteFamily: address[2]\n      };\n    }\n  }]);\n\n  return WebSocket;\n}();\n\nvar WebSocketClient =\n/*#__PURE__*/\nfunction (_WebSocket) {\n  _inherits(WebSocketClient, _WebSocket);\n\n  function WebSocketClient(uri) {\n    var _this2;\n\n    _classCallCheck(this, WebSocketClient);\n\n    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(WebSocketClient).call(this, null));\n    _this2.internalOnOpen = noop;\n    _this2.internalOnError = noop;\n    native.connect(clientGroup, uri, _assertThisInitialized(_assertThisInitialized(_this2)));\n    return _this2;\n  }\n\n  _createClass(WebSocketClient, [{\n    key: \"ping\",\n    value: function ping(message, options, dontFailWhenClosed) {\n      if (this.external) {\n        native.client.send(this.external, message, WebSocketClient.OPCODE_PING, false);\n      }\n    }\n  }, {\n    key: \"terminate\",\n    value: function terminate() {\n      if (this.external) {\n        native.client.terminate(this.external);\n        this.external = null;\n      }\n    }\n  }, {\n    key: \"send\",\n    value: function send(message, options, cb, compress) {\n      if (this.external) {\n        if (typeof options === 'function') {\n          cb = options;\n          options = null;\n        }\n\n        var binary = options && typeof options.binary === 'boolean' ? options.binary : typeof message !== 'string';\n        native.client.send(this.external, message, binary ? WebSocketClient.OPCODE_BINARY : WebSocketClient.OPCODE_TEXT, cb ? function () {\n          process.nextTick(cb);\n        } : undefined, compress);\n      } else if (cb) {\n        cb(new Error('not opened'));\n      }\n    }\n  }, {\n    key: \"close\",\n    value: function close(code, data) {\n      if (this.external) {\n        native.client.close(this.external, code, data);\n        this.external = null;\n      }\n    }\n  }]);\n\n  return WebSocketClient;\n}(WebSocket);\n\nvar Server =\n/*#__PURE__*/\nfunction (_EventEmitter) {\n  _inherits(Server, _EventEmitter);\n\n  function Server(options, callback) {\n    var _this3;\n\n    _classCallCheck(this, Server);\n\n    _this3 = _possibleConstructorReturn(this, _getPrototypeOf(Server).call(this));\n\n    if (!options) {\n      throw new TypeError('missing options');\n    }\n\n    if (options.port === undefined && !options.server && !options.noServer) {\n      throw new TypeError('invalid options');\n    }\n\n    var nativeOptions = 0;\n\n    if (options.perMessageDeflate !== undefined && options.perMessageDeflate !== false) {\n      nativeOptions |= WebSocketClient.PERMESSAGE_DEFLATE;\n\n      if (options.perMessageDeflate.serverNoContextTakeover === false) {\n        nativeOptions |= WebSocketClient.SLIDING_DEFLATE_WINDOW;\n      }\n    }\n\n    _this3.serverGroup = native.server.group.create(nativeOptions, options.maxPayload === undefined ? DEFAULT_PAYLOAD_LIMIT : options.maxPayload); // can these be made private?\n\n    _this3._upgradeCallback = noop;\n    _this3._upgradeListener = null;\n    _this3._noDelay = options.noDelay === undefined ? true : options.noDelay;\n    _this3._lastUpgradeListener = true;\n    _this3._passedHttpServer = options.server;\n\n    if (!options.noServer) {\n      _this3.httpServer = options.server ? options.server : http.createServer(function (request, response) {\n        // todo: default HTTP response\n        response.end();\n      });\n\n      if (options.path && (!options.path.length || options.path[0] !== '/')) {\n        options.path = '/' + options.path;\n      }\n\n      _this3.httpServer.on('upgrade', _this3._upgradeListener = function (request, socket, head) {\n        if (!options.path || options.path == request.url.split('?')[0].split('#')[0]) {\n          if (options.verifyClient) {\n            var info = {\n              origin: request.headers.origin,\n              secure: request.connection.authorized !== undefined || request.connection.encrypted !== undefined,\n              req: request\n            };\n\n            if (options.verifyClient.length === 2) {\n              options.verifyClient(info, function (result, code, name) {\n                if (result) {\n                  _this3.handleUpgrade(request, socket, head, emitConnection);\n                } else {\n                  abortConnection(socket, code, name);\n                }\n              });\n            } else {\n              if (options.verifyClient(info)) {\n                _this3.handleUpgrade(request, socket, head, emitConnection);\n              } else {\n                abortConnection(socket, 400, 'Client verification failed');\n              }\n            }\n          } else {\n            _this3.handleUpgrade(request, socket, head, emitConnection);\n          }\n        } else {\n          if (_this3._lastUpgradeListener) {\n            abortConnection(socket, 400, 'URL not supported');\n          }\n        }\n      });\n\n      _this3.httpServer.on('newListener', function (eventName, listener) {\n        if (eventName === 'upgrade') {\n          _this3._lastUpgradeListener = false;\n        }\n      });\n\n      _this3.httpServer.on('error', function (err) {\n        _this3.emit('error', err);\n      });\n    }\n\n    native.server.group.onDisconnection(_this3.serverGroup, function (external, code, message, webSocket) {\n      webSocket.external = null;\n      process.nextTick(function () {\n        webSocket.internalOnClose(code, message);\n      });\n      native.clearUserData(external);\n    });\n    native.server.group.onMessage(_this3.serverGroup, onServerMessage);\n    native.server.group.onPing(_this3.serverGroup, function (message, webSocket) {\n      webSocket.onping(message);\n    });\n    native.server.group.onPong(_this3.serverGroup, function (message, webSocket) {\n      webSocket.onpong(message);\n    });\n    native.server.group.onConnection(_this3.serverGroup, function (external) {\n      var webSocket = new WebSocket(external);\n      native.setUserData(external, webSocket);\n\n      _this3._upgradeCallback(webSocket);\n\n      _upgradeReq = null;\n    });\n\n    if (options.port !== undefined) {\n      if (options.host) {\n        _this3.httpServer.listen(options.port, options.host, function () {\n          _this3.emit('listening');\n\n          callback && callback();\n        });\n      } else {\n        _this3.httpServer.listen(options.port, function () {\n          _this3.emit('listening');\n\n          callback && callback();\n        });\n      }\n    }\n\n    return _this3;\n  }\n\n  _createClass(Server, [{\n    key: \"handleUpgrade\",\n    value: function handleUpgrade(request, socket, upgradeHead, callback) {\n      var _this4 = this;\n\n      if (socket._isNative) {\n        if (this.serverGroup) {\n          _upgradeReq = request;\n          this._upgradeCallback = callback ? callback : noop;\n          native.upgrade(this.serverGroup, socket.external, secKey, request.headers['sec-websocket-extensions'], request.headers['sec-websocket-protocol']);\n        }\n      } else {\n        var _secKey = request.headers['sec-websocket-key'];\n        var socketHandle = socket.ssl ? socket._parent._handle : socket._handle;\n        var sslState = socket.ssl ? socket.ssl._external : null;\n\n        if (socketHandle && _secKey && _secKey.length == 24) {\n          socket.setNoDelay(this._noDelay);\n          var ticket = native.transfer(socketHandle.fd === -1 ? socketHandle : socketHandle.fd, sslState);\n          socket.on('close', function (error) {\n            if (_this4.serverGroup) {\n              _upgradeReq = request;\n              _this4._upgradeCallback = callback ? callback : noop;\n              native.upgrade(_this4.serverGroup, ticket, _secKey, request.headers['sec-websocket-extensions'], request.headers['sec-websocket-protocol']);\n            }\n          });\n        }\n\n        socket.destroy();\n      }\n    }\n  }, {\n    key: \"broadcast\",\n    value: function broadcast(message, options) {\n      if (this.serverGroup) {\n        native.server.group.broadcast(this.serverGroup, message, options && options.binary || false);\n      }\n    }\n  }, {\n    key: \"startAutoPing\",\n    value: function startAutoPing(interval, userMessage) {\n      if (this.serverGroup) {\n        native.server.group.startAutoPing(this.serverGroup, interval, userMessage);\n      }\n    }\n  }, {\n    key: \"close\",\n    value: function close(cb) {\n      if (this._upgradeListener && this.httpServer) {\n        this.httpServer.removeListener('upgrade', this._upgradeListener);\n\n        if (!this._passedHttpServer) {\n          this.httpServer.close();\n        }\n      }\n\n      if (this.serverGroup) {\n        native.server.group.close(this.serverGroup);\n        this.serverGroup = null;\n      }\n\n      if (typeof cb === 'function') {\n        // compatibility hack, 15 seconds timeout\n        setTimeout(cb, 20000);\n      }\n    }\n  }, {\n    key: \"clients\",\n    get: function get() {\n      var _this5 = this;\n\n      if (this.serverGroup) {\n        return {\n          length: native.server.group.getSize(this.serverGroup),\n          forEach: function forEach(cb) {\n            native.server.group.forEach(_this5.serverGroup, cb);\n          }\n        };\n      }\n    }\n  }]);\n\n  return Server;\n}(EventEmitter);\n\nWebSocketClient.PERMESSAGE_DEFLATE = 1;\nWebSocketClient.SLIDING_DEFLATE_WINDOW = 16; //WebSocketClient.SERVER_NO_CONTEXT_TAKEOVER = 2;\n//WebSocketClient.CLIENT_NO_CONTEXT_TAKEOVER = 4;\n\nWebSocketClient.OPCODE_TEXT = 1;\nWebSocketClient.OPCODE_BINARY = 2;\nWebSocketClient.OPCODE_PING = 9;\nWebSocketClient.OPEN = 1;\nWebSocketClient.CLOSED = 0;\nWebSocketClient.Server = Server;\nWebSocketClient.http = native.httpServer;\nWebSocketClient.native = native;\nmodule.exports = WebSocketClient;","map":null,"metadata":{},"sourceType":"script"}